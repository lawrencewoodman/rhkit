// Copyright (C) 2016-2017 vLife Systems Ltd <http://vlifesystems.com>
// Licensed under an MIT licence.  Please see LICENSE.md for details.

package rule

import (
	"github.com/lawrencewoodman/ddataset"
	"github.com/lawrencewoodman/dlit"
	"github.com/vlifesystems/rhkit/description"
	"sort"
)

// InFV represents a rule determining if field is equal to
// any of the supplied values when represented as a string
type InFV struct {
	field  string
	values []*dlit.Literal
}

func init() {
	registerGenerator("InFV", generateInFV)
}

func NewInFV(field string, values []*dlit.Literal) *InFV {
	if len(values) == 0 {
		panic("NewInFV: Must contain at least one value")
	}
	return &InFV{field: field, values: values}
}

func makeInFVString(field string, values []*dlit.Literal) string {
	return "in(" + field + "," + commaJoinValues(values) + ")"
}

func (r *InFV) String() string {
	return makeInFVString(r.field, r.values)
}

func (r *InFV) Fields() []string {
	return []string{r.field}
}

func (r *InFV) Values() []*dlit.Literal {
	return r.values
}

func (r *InFV) IsTrue(record ddataset.Record) (bool, error) {
	needle, ok := record[r.field]
	if !ok {
		return false, InvalidRuleError{Rule: r}
	}
	if needle.Err() != nil {
		return false, IncompatibleTypesRuleError{Rule: r}
	}
	for _, v := range r.values {
		if needle.String() == v.String() {
			return true, nil
		}
	}
	return false, nil
}

func (r *InFV) Overlaps(o Rule) bool {
	switch x := o.(type) {
	case *InFV:
		oValues := x.Values()
		oField := x.Fields()[0]
		if r.field != oField {
			return false
		}
		for _, v := range r.values {
			for _, oV := range oValues {
				if v.String() == oV.String() {
					return true
				}
			}
		}
	}
	return false
}

func generateInFV(
	inputDescription *description.Description,
	generationDesc GenerationDescriber,
) []Rule {
	extra := 0
	if len(generationDesc.Fields()) == 2 {
		extra += 3
	}
	rules := make([]Rule, 0)
	for _, field := range generationDesc.Fields() {
		fd := inputDescription.Fields[field]
		numValues := len(fd.Values)
		if fd.Kind != description.String && fd.Kind != description.Number ||
			numValues <= 3 || numValues > (12+extra) {
			continue
		}
		possibleLits := possibleValuesToLiterals(fd.Values)
		maxNumLits := 5 + extra
		if maxNumLits > numValues-2 {
			// numvalues-2 is used because numValues-1 is equivalent to saying that
			// a field is != 'value', which is generated by the NEFV rule
			maxNumLits = numValues - 2
		}
		litCombinations := literalCombinations(possibleLits, 2, maxNumLits)
		for _, compareValues := range litCombinations {
			r := NewInFV(field, compareValues)
			rules = append(rules, r)
		}
	}
	return rules
}

func getMaskLiterals(mask string, values []*dlit.Literal) []*dlit.Literal {
	r := []*dlit.Literal{}
	for j, b := range mask {
		if j >= len(values) {
			break
		}
		if b == '1' {
			v := values[j]
			r = append(r, v)
		}
	}
	return r
}

func literalCombinations(
	values []*dlit.Literal,
	min,
	max int,
) [][]*dlit.Literal {
	r := [][]*dlit.Literal{}
	for i := 3; ; i++ {
		mask := makeMask(len(values), i)
		numOnBits := countNumOnBits(mask)
		if len(mask) > len(values) {
			break
		}
		if numOnBits >= min && numOnBits <= max && numOnBits <= len(values) {
			r = append(r, getMaskLiterals(mask, values))
		}
	}
	return r
}

func possibleValuesToLiterals(
	values map[string]description.Value,
) []*dlit.Literal {
	lits := []*dlit.Literal{}
	keys := make([]string, len(values))
	i := 0
	for k := range values {
		keys[i] = k
		i++
	}

	// The keys are sorted to make it easier to test because maps aren't ordered
	sort.Strings(keys)
	for _, k := range keys {
		if values[k].Num >= 2 {
			lits = append(lits, values[k].Value)
		}
	}
	return lits
}
